SELECT [au_id], [au_fname] + ' ' + [au_lname] AS Name FROM [authors]


SELECT TITLE
FROM AUTHOR
	INNER JOIN TITLEAUTHOR
		ON @au_id = TITLEAUTHOR.AU_ID
	INNER JOIN TITLES 
		ON TITLEAUTHOR.AU_ID =  @au_id

SELECT TITLE
FROM AUTHOR
	INNER JOIN TITLEAUTHOR 
		ON TITLEAUTHOR.AU_ID = AUTHOR.AU_ID
	INNER JOIN TITLES
		ON TITLES.TITLE_ID = TITLEAUTHOR.TITLE_ID
WHERE
	AUTHOR.AU_ID = --AUTHOR ID VALUE 

/*
	Session

	Default1
	Before response Redirect
	Session.["infoToPassAlong"] = "Ben";
	
	Default2
	Drag a label
	Label1.Text = Session["infoToPassAlong"].ToString();
*/

CREATE PROCEDURE GET_AUTHOR_DETAIL
(
	@AU_ID VARCHAR(30)
)
AS
SELECT 
	AU_FNAME,
	AU_LNAME,
	PHONE,
	ADDRESS,
	CITY,
	STATE,
	ZIP
FROM AUTHORS 

===========================
--CREATE AUTHOR_BAK
CREATE TABLE AUTHORS_BAK
(
	AU_ID VARCHAR(11) NOT NULL,
	AU_LNAME VARCHAR(40) NOT NULL,
	AU_FNAME VARCHAR(20) NOT NULL,
	PHONE CHAR(12) NOT NULL,
	ADDRESS VARCHAR(40) NULL,
	CITY VARCHAR(20) NULL,
	STATE CHAR(2) NULL,
	ZIP CHAR(5) NULL,
	CONTRACT BIT NOT NULL,
	OPERATION CHAR(1)
)

--INSERT/POPULATE BACKUP
INSERT INTO AUTHORS_BAK
(
	AU_ID, 
	AU_LNAME, 
	AU_FNAME, 
	PHONE,
	ADDRESS,
	CITY,
	STATE,
	ZIP,
	CONTRACT
)
SELECT 
	AU_ID, 
	AU_LNAME, 
	AU_FNAME, 
	PHONE,
	ADDRESS,
	CITY,
	STATE,
	ZIP,
	CONTRACT
FROM AUTHORS

SELECT * INTO TITLEAUTHOR FROM TITLEAUTHOR_BAK
WHERE 1=2

ALTER TABLE TITLEAUTHOR_BAK
ADD OPERATION CHAR(1)

--CREATE TRIGGER FOR INSERT AUTHORS
CREATE TRIGGER TR_IN_AUTHORS
	ON AUTHORS
	FOR INSERT
AS
INSERT INTO AUTHORS_BAK
(
	AU_ID, 
	AU_LNAME, 
	AU_FNAME, 
	PHONE,
	ADDRESS,
	CITY,
	STATE,
	ZIP,
	CONTRACT
)
SELECT *
FROM INSERTED --TMP TABLE DURING TRIGGER
--AND UPDATE OPERATION
UPDATE AUTHORS_BAK
	SET OPERATION = 'I'
FROM AUTHORS_BAK
	INNER JOIN INSERTED
	ON AUTHORS_BAK.AU_ID = INSERTED.AU_ID

INSERT INTO AUTHORS
VALUES
(
	'111-11-1111', 
	'LTEST', 
	'FTEST', 
	'000 000-0000',
	'1234 TEST ADDRESS',
	'TESTCITY',
	'AA',
	'00000',
	1
)

===========================
--CREATE TRIGGER FOR DELETE AUTHORS
CREATE TRIGGER TR_DEL_AUTHORS
	ON AUTHORS
	INSTEAD OF DELETE
AS
--INSERT TO AUTHORS_BAK
INSERT INTO AUTHORS_BAK
(
	AU_ID, 
	AU_LNAME, 
	AU_FNAME, 
	PHONE,
	ADDRESS,
	CITY,
	STATE,
	ZIP,
	CONTRACT
)
SELECT *
FROM DELETED --TMP TABLE DURING TRIGGER

--UPDATE AUTHORS_BAK
UPDATE AUTHORS_BAK
	SET OPERATION = 'D'
FROM AUTHORS_BAK
	INNER JOIN DELETED
		ON AUTHORS_BAK.AU_ID = DELETED.AU_ID

--INSERT TO TITLEAUTHOR_BAK
INSERT INTO TITLEAUTHOR_BAK
(
	AU_ID,
	TITLE_ID,
	AU_ORD,
	ROYALTYPER
)
SELECT
	TITLEAUTHOR.AU_ID,
	TITLEAUTHOR.TITLE_ID,
	TITLEAUTHOR.AU_ORD,
	TITLEAUTHOR.ROYALTYPER
FROM TITLEAUTHOR
	INNER JOIN AUTHORS ON AUTHORS.AU_ID = TITLEAUTHOR.AU_ID
	INNER JOIN DELETED ON DELETED.AU_ID = TITLEAUTHOR.AU_ID

--UPDATE TITLEAUTHOR_BAK
UPDATE TITLEAUTHOR_BAK
	SET OPERATION = 'D'
FROM TITLEAUTHOR_BAK
	INNER JOIN DELETED
		ON DELETED.AU_ID = TITLEAUTHOR_BAK.AU_ID

--DELETE TITLEAUTHOR
DELETE FROM TITLEAUTHOR
WHERE
	TITLEAUTHOR.AU_ID = 
		(
			SELECT AU_ID
			FROM DELETED
		)

--DELETE AUTHORS
DELETE FROM AUTHORS
WHERE
	AUTHORS.AU_ID = 
		(
			SELECT AU_ID
			FROM DELETED
		)

===========================

INSERT INTO AUTHORS
(
	AU_ID, 
	AU_LNAME, 
	AU_FNAME, 
	PHONE,
	ADDRESS,
	CITY,
	STATE,
	ZIP,
	CONTRACT
)
VALUES
(
	au_id,
	lname,
	fname,
	phone,
	address,
	city,
	state,
	state,
	zip,
	contract
);

===========================

DELETE FROM AUTHORS
WHERE
	AUTHORS.AU_ID = ''

===========================

CREATE TABLE SALARY
(
	ID INT,
	EMPLOYEENAME VARCHAR(128),
	JOBTITLE VARCHAR(128),
	BASEPAY DECIMAL(18,8),
	OVERTIMEPAY DECIMAL(18,8),
	OTHERPAY DECIMAL(18,8),
	BENEFITS DECIMAL(18,8),
	TOTALPAYBENEFITS DECIMAL(18,8),
	YEAR INT,
	NOTES VARCHAR(128),
	AGENCY VARCHAR(128),
	STATUS VARCHAR(128)
)

===========================
SELECT DISTINCT
	JOBTITLE,
	AVG(TOTALPAYBENEFITS) AS TPB
FROM SALARIES
WHERE 
	YEAR = 2014
GROUP BY JOBTITLE
ORDER BY TPB DESC

SELECT
	EMPLOYEENAME,
	JOBTITLE,
	YEAR,
	AVG(TOTALPAYBENEFITS) AS TPB
FROM SALARIES
WHERE 
	--YEAR = 2014
	JOBTITLE LIKE '%Investment%'
GROUP BY JOBTITLE, EMPLOYEENAME, YEAR
ORDER BY TPB DESC



SELECT
	JOBTITLE,
	YEAR,
	AVG(TOTALPAYBENEFITS) AS TPB
FROM SALARIES
WHERE 
	YEAR = 2014
	AND 
	(
		JOBTITLE LIKE '%ACCOUNTANT INTERN%'
		OR JOBTITLE LIKE '%ASSISTANT RECRE%'
		OR JOBTITLE LIKE '%BEAUT%'
		OR JOBTITLE LIKE 'CLERK'
		OR JOBTITLE LIKE '%CRAFT%'
		OR JOBTITLE LIKE '%HOME HEALTH%'
		OR JOBTITLE LIKE '%MUSEUM G%'
		OR JOBTITLE LIKE 'MUSEUM P%'
		OR JOBTITLE LIKE 'RECREATION SP%'
		OR JOBTITLE LIKE '%CADET%'
	)
GROUP BY JOBTITLE, YEAR
ORDER BY TPB ASC

===========================
--CREATE TMP TABLE
CREATE TEMPORARY TABLE TMP
(
	DATE DECIMAL(14,4) NOT NULL,
	NAME VARCHAR(128) NULL,
	EMAIL VARCHAR(128) NULL
)

--INSERT ALL DATES
INSERT INTO TMP
(
	DATE
)	
SELECT DISTINCT WP_COL1
FROM WP_TABLE

--INSERT NAME
INSERT INTO TMP
(
	NAME
)
SELECT WP_COL3
FROM WP_TABLE
	INNER JOIN TMP ON TMP.DATE = WP_TABLE.WP_COL1
WHERE 
	WP_COL2 = 'USERNAME'

--INSERT EMAIL
INSERT INTO TMP
(
	EMAIL
)
SELECT WP_COL3
FROM WP_TABLE
	INNER JOIN TMP ON TMP.DATE = WP_TABLE.WP_COL1
WHERE 
	WP_COL2 = 'USEREMAIL'

--RETURNS TMP FINAL RESULT 
SELECT 
	DATE,
	NAME,
	EMAIL
FROM TMP 


===========================


INSERT INTO USER
(
  ID,
  EMAIL,
  PASSWORD
)
VALUES
(
  DEFAULT,
  'danlin604@gmail.com',
  '3900bcit'
)


===========================
--WARM UP

SELECT
	COUNT(DISTINCT ZIPCODE)
FROM ZIPCENSUS


SELECT DISTINCT
	LEFT(ZIPCODE, 3) AS SCF --FIRST 3 DIGITS
FROM ZIPCENSUS
ORDER BY SCF

--COUNT # OF ZIPCODE PER SCF
SELECT 
	LEFT(ZIPCODE, 3) AS SCF,
	COUNT(*)
FROM ZIPCENSUS
GROUP BY LEFT(ZIPCODE,3)
ORDER BY SCF

SELECT 
	STATE,
	COUNT(ZIPCODE) AS ZIPCODE
FROM ZIPCENSUS
GROUP BY STATE
ORDER BY STATE

SELECT 
	STATE,
	COUNT(DISTINCT LEFT(ZIPCODE,3)) AS SCF
FROM ZIPCENSUS
GROUP BY STATE
ORDER BY STATE

SELECT 
	ZIPCODE,
	POPULATION
FROM ZIPCENSUS
ORDER BY ZIPCODE

SELECT 
	DATE,
	HOLIDAYNAME,
	HOLIDAYTYPE
FROM CALENDAR
WHERE 
	HOLIDAYTYPE = 'NATIONAL'
	AND DATEPART(YEAR, DATE) = 2016 --GRABS DATE VALUE AND EXTRACT

SELECT 
	DATEPART(MONTH, DATE) AS MONTH, 
	COUNT(*) AS NUM_HOLIDAYS
FROM CALENDAR
WHERE 
	HOLIDAYTYPE = 'NATIONAL'
	AND DATEPART(YEAR, DATE) = 2016 --GRABS DATE VALUE AND EXTRACT
GROUP BY DATEPART(MONTH, DATE)

--CASE STATEMENTS
SELECT 
	MONTHNAME =
		CASE MONTH
			WHEN 1 THEN 'JANUARY'
			WHEN 2 THEN 'FEBRARY'
			...
			WHEN PRICE >= AND < 300 THEN 'HEYYY'
			ELSE 'YOOOO'
		END
FROM CALENDAR
WHERE 
	HOLIDAYTYPE = 'NATIONAL'
	AND DATEPART(YEAR, DATE) = 2016 --GRABS DATE VALUE AND EXTRACT
GROUP BY DATEPART(MONTH, DATE)

--FIND # OF POPULATION GREATER FOR EACH ZIPCODE
SELECT 
	Z1.STATE,
	Z1.ZIPCODE,
	COUNT(*)
FROM ZIPCENSUS Z1
	INNER JOIN ZIPCENSUS Z2 ON Z1.STATE =Z2.STATE
WHERE Z1.POPULATION < Z2.POPULATION
GROUP BY Z1.ZIPCODE, Z1.STATE
ORDER BY Z1.ZIPCODE


--COUNT FASTER

SELECT 
	Z1.STATE,
	SUM
	(
		CASE WHEN Z1.POPULATION < Z2.POPULATION
			THEN 1  --1 FOR SUMMING COUNT
		ELSE 0 END	--0 FOR SUMMING COUNT
	) AS NUMZIP
FROM ZIPCENSUS Z1
	INNER JOIN ZIPCENSUS Z2 ON Z1.STATE =Z2.STATE
WHERE Z1.POPULATION < Z2.POPULATION
GROUP BY Z1.ZIPCODE
ORDER BY Z1.ZIPCODE


--USING SUBQUERIES

SELECT
	SUM(...)
FROM
(
	SELECT 
		CASE WHEN...
		...
	FROM ZIPCENSUS ZC
) ZC

--NON CORRELATED SUBQUERY
	--INFO FROM INNNER TABLE
--CORRELATED
	--INFO FROM OUTSIDE TABLE



SELECT CUSTOMERID, P.PRODUCTID, P.NAME
FROM SALES.SALESORDERHEADER SH
	INNER JOIN SALES.SALESORDERDETAIL SD ON SD.SALESORDERID = SH.SALESORDERID 
	INNER JOIN PRODUCTION.PRODUCT P ON SD.PRODUCTID = P.PRODUCTID
ORDER BY CUSTOMERID


SELECT
	SH.CUSTOMERID,
    CustomColumn = STUFF((
            SELECT ', ' + REPLACE(P.NAME,',','')
				REPLACE(P.NAME,',','') AS PRODUCT
			FROM SALES.SALESORDERHEADER SH
				INNER JOIN SALES.SALESORDERDETAIL SD ON SD.SALESORDERID = SH.SALESORDERID 
				INNER JOIN PRODUCTION.PRODUCT P ON SD.PRODUCTID = P.PRODUCTID
            FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 1, '')
FROM SALES.SALESORDERHEADER SH
	INNER JOIN SALES.SALESORDERDETAIL SD ON SD.SALESORDERID = SH.SALESORDERID 
	INNER JOIN PRODUCTION.PRODUCT P ON SD.PRODUCTID = P.PRODUCTID
ORDER BY SH.CUSTOMERID


SELECT
	SOD2.CUSTOMERID,
    CustomColumn = STUFF((
            SELECT ', ' + cpp2.Name
            FROM Production.Product cpp2
            JOIN Sales.SalesOrderDetail sod1
                ON sod1.ProductID = cpp2.ProductID
            WHERE sod1.SalesOrderID=sod2.SalesOrderID
            FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 1, '')
FROM Sales.SalesOrderHeader sod2
JOIN Sales.Customer
    ON sod2.CustomerID = Customer.CustomerID
JOIN Person.Person
    ON Customer.PersonID = Person.BusinessEntityID
ORDER BY SOD2.CUSTOMERID



SELECT DISTINCT
    CUSTOMCOLUMN = STUFF((
            SELECT ', ' + REPLACE(P.NAME,',','')
			FROM SALES.SALESORDERHEADER SH1
				INNER JOIN SALES.SALESORDERDETAIL SD ON SD.SALESORDERID = SH1.SALESORDERID 
				INNER JOIN PRODUCTION.PRODUCT P ON SD.PRODUCTID = P.PRODUCTID
			WHERE SH2.CUSTOMERID = SH1.CUSTOMERID
            FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 1, '')
FROM SALES.SALESORDERHEADER SH2



CREATE PROCEDURE SP_AUTHOR_PUBLISHER 
(
	@AUTHOR BIT,
	@FNAME	VARCHAR(30),
	@LNAME	VARCHAR(30)
)
AS 
	IF (@AUTHOR = 1)
	BEGIN
		SELECT *
		FROM AUTHORS
		WHERE
			AU_LNAME = @LNAME
			AND AU_FNAME = @FNAME
	END
	ELSE
		SELECT *
		FROM PUBLISHERS

CREATE TRIGGER TR_1
	ON ROYSCHED
	INSTEAD OF UPDATE
AS
DECLARE @MAX INT
SET @MAX =
(
	SELECT MAX(ROYALTY)
	FROM ROYSCHED
)
DECLARE @MIN INT
SET @MIN =
(
	SELECT MIN(ROYALTY)
	FROM ROYSCHED
)
UPDATE ROYSCHED
	SET ROYALTY = U.ROYALTY
FROM INSERTED U
	INNER JOIN ROYSCHED R ON R.TITLE_ID = U.TITLE_ID
WHERE 
	U.ROYALTY < @MAX
	AND U.ROYALTY > @MIN

===========================

/*
*	PATTERNS AND ANTI-PATTERNS IN SQL
*/

--JAYWALKING (ANTIPATTERN)
	Multivalue attribute storing '12,34' into ACCOUNT_ID

	legitimate use: If you need to store just a list.

	--PATTERN
		Create intersection / bridge table
		
--


DROP TABLE NS

CREATE TABLE NS (
	ID BIGINT IDENTITY PRIMARY KEY,
	NLEFT INTEGER NOT NULL,
	NRIGHT INTEGER NOT NULL,
	NAME VARCHAR(16) NOT NULL,
	TITLE VARCHAR(16) NOT NULL
);

-- make space for NS values 8 and 9
UPDATE NS
SET NLEFT = 
		CASE WHEN NLEFT >= 1
			THEN NLEFT+2
		ELSE NLEFT END,
	NRIGHT = NRIGHT+2
WHERE NRIGHT >= 1;
-- create new child of comment #5,
-- occupying NS values 8 and 9
INSERT INTO NS (NLEFT, NRIGHT, NAME, TITLE)
VALUES (1, 2, 'PETER', 'CIO');

UPDATE NS
SET NLEFT = 
		CASE WHEN NLEFT >= 2
			THEN NLEFT+2
		ELSE NLEFT END,
	NRIGHT = NRIGHT+2
WHERE NRIGHT >= 2;
-- create new child of comment #5,
-- occupying NS values 8 and 9
INSERT INTO NS (NLEFT, NRIGHT, NAME, TITLE)
VALUES (2, 3, 'JOHN', 'MANAGER');

UPDATE NS
SET NLEFT = 
		CASE WHEN NLEFT >= 4
			THEN NLEFT+2
		ELSE NLEFT END,
	NRIGHT = NRIGHT+2
WHERE NRIGHT >= 4;
-- create new child of comment #5,
-- occupying NS values 8 and 9
INSERT INTO NS (NLEFT, NRIGHT, NAME, TITLE)
VALUES (4, 5, 'AMANDA', 'MANAGER');


UPDATE NS
SET NLEFT = 
		CASE WHEN NLEFT >= 3
			THEN NLEFT+2
		ELSE NLEFT END,
	NRIGHT = NRIGHT+2
WHERE NRIGHT >= 3;
-- create new child of comment #5,
-- occupying NS values 8 and 9
INSERT INTO NS (NLEFT, NRIGHT, NAME, TITLE)
VALUES (3, 4, 'MARY', 'DESIGNER');

UPDATE NS
SET NLEFT = 
		CASE WHEN NLEFT >= 9
			THEN NLEFT+2
		ELSE NLEFT END,
	NRIGHT = NRIGHT+2
WHERE NRIGHT >= 9;
-- create new child of comment #5,
-- occupying NS values 8 and 9
INSERT INTO NS (NLEFT, NRIGHT, NAME, TITLE)
VALUES (7, 8, 'RALPH', 'DEVELOPER');

UPDATE NS
SET NLEFT = 
		CASE WHEN NLEFT >= 11
			THEN NLEFT+2
		ELSE NLEFT END,
	NRIGHT = NRIGHT+2
WHERE NRIGHT >= 11;
-- create new child of comment #5,
-- occupying NS values 8 and 9
INSERT INTO NS (NLEFT, NRIGHT, NAME, TITLE)
VALUES (9, 10, 'JEANNE', 'TESTER');

SELECT *
FROM NS



CREATE PROCEDURE SP_WAITLIST
(
	@EMAIL VARCHAR(128)
)
AS
SELECT 

FROM WAITLIST
WHERE
	NOTIFICATION_TIME =


CREATE PROCEDURE SP_WAITLIST()
BEGIN

	-- CHECK FOR EXPIRED
	UPDATE WAITLIST
		SET QUEUE = NULL, EXPIRED = 1
	WHERE
		NOTIFICATION_TIME = NULL
		AND (CURDATE() - 7) > NOTIFICATION_TIME
		
	--MOVE QUEUE
	UPDATE WAITLIST
		SET QUEUE = QUEUE - 1
	WHERE 
		QUEUE IS NOT NULL
		AND QUEUE <> 1

	--UPDATE NOTIFICATION_TIME
	UPDATE WAITLIST 
		SET NOTIFICATION_TIME = CURDATE()
	WHERE 
		QUEUE = 1
		
END





